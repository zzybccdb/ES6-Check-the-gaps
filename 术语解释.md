# 术语解释

## SPA

## SSR

## CSR

## ES Module
type = module

ES6在语言标准的层面上，实现了模块化功能，而且实现的相当简单，旨在成为浏览器和服务器通用的模块化解决方案。

其模块化功能主要由俩个命令构成：exports和import，export命令由于规定模块的对外接口，import命令用于输入其他模块的功能。

ES6还提供了export default的命令。为模块指定默认输出。对应的import语句不需要大括号。

## CommonJS
node 应用采用的模块标准，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。

CommonJS 规范加载模块是同步， AMD（Asynchronous Module Definition） 规范则是非同步加载模块，允许指定回调函数。

暴露模块：module.exports = value;或者exports.xxx = value;

引入模块：const xxx = require('xxxx')

__dirname代表当前模块所在的文件路径

__filename代表当前模块文件所在的文件路径+文件名

## UMD
UMD（Universal Module Definition）提供了支持多种风格的“通用”模式，在兼容CommonJS和AMD规范的同时，还兼容全局引用的方式

UMD实现原理很简单：

先判断是否支持AMD（define 是否存在），存在则使用 AMD 方式加载模块；
再判断是否支持 Node.js 模块格式（exports是否存在），存在则使用 Node.js 模块格式；
前两个都不存在，则将模块公开到全局（window 或 global）
UMD 使得你可以直接使用 <script> 标签引用

## 柯里化

柯里化意味着将具有 n 个参数的函数转换为具有一个或更少参数的 n 个函数。

例如，假设你有一个将两个数字相加的函数 add()：

```
function add(a, b) {
    return a + b;
}
```

```
// 实现一个add方法，使计算结果能够满足如下预期：
// add(1)(2)(3) = 6;
// add(1, 2, 3)(4) = 10;
// add(1)(2)(3)(4)(5) = 15;

function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    let _args = Array.prototype.slice.call(arguments);

    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    let _adder = function () {
        _args.push(...arguments);
        return _adder;
    };

    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
    _adder.toString = function () {
        // return _args.reduce(function (a, b) {
        //     return a + b;
        // },0);
        return [].reduce.call(_args, (a, b) => a + b, 0)
    }

    return _adder
}

console.log(add(1)(3)(3, 4))

function curry(fn, currArgs) {
    return function () {
        let args = [].slice.call(arguments);

        // 首次调用时，若未提供最后一个参数currArgs，则不用进行args的拼接
        if (currArgs !== undefined) {
            args = args.concat(currArgs);
        }

        // 递归调用
        if (args.length < fn.length) {
            return curry(fn, args);
        }

        // 递归出口
        return fn.apply(null, args);
    }
}
```

